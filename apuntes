/* Documento: sesionUno.playground
 * Autor: Cristian Tafolla Rosales
 * Asignatura: Desarrollo con Swift
 * Semestre: 2020 - 1 */

import UIKit

/* Antes que nada, es necesario decir que comentarÃ© este cÃ³digo como muchos otros
 * utilizando algunas notaciones sencillas*/

// Este es un comentario de una lÃ­nea

/* Constantes y variables
 
 * En ambos casos, son espacios reservados en la memoria principal del equipo.
 * Las constantes y las variables son utilizadas para asociar un nombre con un valor.

 * Constante: Tiene un valor ajustado que no requiere que sea cambiado durante el
 * "tiempo de vida" de un programa, siendo mÃ¡s claros y seguros.
 * Podemos definir las constantes con la palabra reservada let, como en el siguiente
 * ejemplo: */

let curso = "Desarrollo con Swift"

/* La sentencia anterior nos indica que existirÃ¡ una nueva constante llamada curso
 * y se le asigno el valor Desarrollo con Swift a dicha constante.

 * En la siguiente lÃ­nea imprimiremos el valor de dicha constante, la cuÃ¡l aparecerÃ¡
 * en la consola que se encuentra en la parte inferior de nuestra ventana activa.:*/

print (curso)

/* Variable: En caso de requerir un valor que cambie durante la ejecuciÃ³n del programa,
 * utilizamos una variable.
 * Podemos declarar las variables con la palabra reservada var, como en el siguiente
 * ejemplo: */

var numeroAlumnos = 6

/* Adicionalmente, vemos que Swift usa inferencia de tipos para seguir
 * trabajando con el tipo adecuado, al declarar una constante o variable con
 * valor inicial.

 * Suponiendo que tenemos la siguiente instrucciÃ³n: */

let pi = 3 + 0.14159

/* El valor literal 3 no tiene un tipo explÃ­cito, asÃ­ que se tomarÃ¡ el tipo mÃ¡s
 * apropiado para almacenar este valor, que en este caso es Double.*/

/* Al guardar los valores, vemos que tenemos que brindarle un nombre diferente a cada
 * uno, como por ejemplo: */

var saludo = "Hola"
var Ð¿Ñ€Ð¸Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ = "Ð¿Ñ€Ð¸Ð²ÐµÑ‚"
var å®£è¨€ = "ç§ã¯ã‚ãªãŸã‚’æ„›ã—ã¦ã„ã‚‹"
var ðŸ˜„ = "Feliz"

/* Estos nombres pueden contener cualquier caracter, incluyendo los caracteres Unicode.

 * Pero lo ideal serÃ­a nombrar las variables con un lenguaje entendible por el grupo
 * de personas que pudisesen verlo, claro, que si queremos que sea algo universal
 * tendremos que utilizar el inglÃ©s, y adicionalmente utilizaremos una notaciÃ³n
 * denominada CamelCase.
 * La notaciÃ³n CamelCase separa cada palabra con una mayÃºscula, y no con espacios
 * entre las palabras. Hay dos formas de utilizarla: */

var numeroAlumnosAprobados = 20 // Utiliza lowerCamelCase

var NumeroAlumnosReprobados = 1 // Utiliza UpperCamelCase

// Lo mejor es utilizar lowerCamelCase.

/* Cabe recalcar que no necesariamente se tiene que imprimir el valor de una variable
 * o constante sola, sino que tambiÃ©n podemos agregar texto de manera contigua.
 * Hay dos formas de hacerlo:
 * 1. ConcatenaciÃ³n: Utilizaremos el sÃ­mbolo "+" entre las cadenas de caracteres.
 * Ejemplo: */

print ("Hola a los " + numeroAlumnos + " del semestre actual")

/* 2. InterpolaciÃ³n: Utilizaremos los sÃ­mbolos \() , y en medio de los parÃ©ntesis 
 * podremos el nombre del espacio de memoria reservado. Ejemplo: */

print ("Actualmente hay \(numeroAlumnos) alumnos inscritos")

/* Suponiendo que esta variable corresponda al nÃºmero de alumnos que el curso tiene y
 * en caso de que lleguen mÃ¡s, entonces podrÃ­amos cambiar el valor almacenado en dicha 
 * variable de la siguiente forma: */

numeroAlumnos = 22
print ("Actualmente hay \(numeroAlumnos) alumnos inscritos")

/* TambiÃ©n podemos declarar multiples constantes o variables en la misma lÃ­nea.*/

let alumnoUno = "Alejandro", alumnoDos = "Julieta", alumnoTres = "Ariel"
var equipoUno = "Ocupado", equipoDos = "Desocupado", equipoTres = "En mantenimiento"

/* Si quisieramos cambiar el valor de una constante, veremos que saldrÃ¡ un error.
 * Descomenta la lÃ­nea de abajo y observa todo lo que aparece. */

//curso = "TeorÃ­a del meme"

/* Como vimos, no es posible cambiar el valor de alguno de las constantes.*/

/* Tipos de datos
 * Los tipos de datos mÃ¡s comunes en Swift son los siguientes:
 
 * Tipo de dato         Palabra reservada           PropÃ³sito
 
 * Entero               Int                         Representa nÃºmeros enteros
 * Flotantes            Float                       Representa nÃºmeros con punto
 *                                                  decimal (6 decimales).
 * Double               Double                      Representa nÃºmeros con punto
 *                                                  decimal, con el doble de
 *                                                  precisiÃ³n que los flotantes
 *						    (15 decimales)
 * Booleano             Bool                        Representa dos valores:
 *                                                  verdadero y falso (true / 
 *						    false)
 * Cadena               String                      Representa texto
 
 * Nosotros podemos ver ejemplos en la parte de abajo: */

var entero: Int = 4
var flotante: Float = 4.66666666666
var double: Double = 4.666666666666
var booleano: Bool = true
var cadena: String = "iOS Dev Lab"

/* Al agregar nosotros el tipo de la variable que estamos definiendo, hacemos que
 * nuestra variable tenga tipado fuerte. Aprovechando esta cualidad del lenguaje,
 * podemos ser mÃ¡s claros con los tipos de valor para trabajar y evitar errores.
 
 * Pero, Â¿quÃ© tal si nosotros no definimos ese tipo? */

var materiaReprobada = "MatemÃ¡ticas financieras"

/* AquÃ­ utilizamos la inferencia de tipo, donde vemos que no es necesario que
 * agreguemos el tipo, aunque lo mejor serÃ­a que lo hicieramos ðŸ™ƒ*/

/* Anotaciones de tipo
 * Podemos declarar claramente el tipo de valor que almacenarÃ¡ una constante o 
 * una variable antes de incluir un valor.
 * Por ejemplo: */

var mensajeBienvenido: String

// para despues continuar asignando valores:

mensajeBienvenido = "Â¡QuÃ© tal todos!"

/* De igual forma podemos definir mÃºltiples variables con el mismo tipo sobre
 * la misma lÃ­nea de cÃ³digo, de manera contigua al nombre de la variable final*/

// Algunos ejemplos simples:

/* Se nos presenta el siguiente problema:
 
 * "La poblaciÃ³n en MÃ©xico ascendÃ­a a los 119,938,473 habitantes." (INEGI, 2015)
 
 * Si requiero guardar esa informaciÃ³n en una variable, lo hago de esta manera: */

var habitantesMexico: Int = 119938473

/* Lo anterior no me permite leer fÃ¡cilmente el nÃºmero de habitantes, pues estamos
 * acostumbrados a leer las cantidades con comas que separan por miles. Bien,
 * Swift puede permitirnos hacer lo siguiente:
 
 * "Para 2019, la poblaciÃ³n en MÃ©xico aumentÃ³ a 133,337,506 habitantes." (CountryMeters, 2019)
 
 * Ahora hay que guardar dicha informaciÃ³n en la variable: */

habitantesMexico = 133_337_526

/* Dicha notaciÃ³n no cambiarÃ¡ el tipo de la variable que ocupÃ¡bamos con  
 * anterioridad y, como vemos, es mÃ¡s fÃ¡cil leerla ahora.*/

/* Operadores: SÃ­mbolos especiales utilizados para cambiar o combinar valores
 
 * Operadores aritmÃ©ticos:
 
 * Ahora hagamos algo diferente. Tenemos la siguiente informaciÃ³n:
 
 * "La poblaciÃ³n masculina actual del paÃ­s es de 65,757,788 habitantes, correspondiente
 * al 49.3%." (CountryMeters, 2019)
 
 * Necesitamos saber ahora cuÃ¡ntas mujeres hay actualmente en MÃ©xico. */

var habitantesMujeres: Int = habitantesMexico - 65_757_788

/* Veremos en la barra lateral de resultados que actualmente hay en MÃ©xico 67,579,738
 * mujeres. DespuÃ©s nos dan mÃ¡s informaciÃ³n:
 
 * "La poblaciÃ³n femenina en MÃ©xico corresponde al 50.7% del total." (CountryMeters, 2019)
 
 * Necesitamos hacer el cÃ¡lculo para saber si es cierta esta afimaciÃ³n. */

50.7 + 49.3

/* TambiÃ©n nos solicitan cuÃ¡ntos habitantes hay por kilÃ³metro cuadrado en el paÃ­s,
 * teniendo el siguiente dato:
 
 * "La extensiÃ³n de la superficie continental de MÃ©xico es de 1,960,189 kilÃ³metros
 * cuadrados" (INEGI, 2010) */

var superficieMexico: Int = 1_960_189

var densidadPoblacionMexico: Float

// Descomenta la lÃ­nea de abajo, y verÃ¡s que hay un error, aunque lÃ³gicamente estÃ¡ bien

// densidadPoblacionMexico = habitantesMexico / superficieMexico

/* Es importante recalcar que obtendrÃ¡s un valor con punto decimal, asÃ­ que se usa un
 * casteo, que es una forma de que le indiquemos al compilador que haremos una conversiÃ³n
 * para no perder informaciÃ³n que nos pueda ser Ãºtil o que hayan problemas en nuestro
 * programa. Lo utilizamos de la siguiente forma: */

densidadPoblacionMexico = Float (habitantesMexico / superficieMexico)

// Vemos que hay 68 personas por kilÃ³metro cuadrado, aproximadamente.

/* Nos brindan mÃ¡s informaciÃ³n:
 
 * "La densidad de carreteras en el paÃ­s corresponde a los 19 kilÃ³metros por kilÃ³metro
 * cuadrado" (SEMARNAT, 2015).

 * Hagamos otra operaciÃ³n. */

var densidadCarreterasMexico: Int = 19

var carreterasMexico: Int = densidadCarreterasMexico * superficieMexico

/* AsignaciÃ³n compuesta
 
 * Suponiendo que en lo que llevamos hablando aumentÃ³ la poblaciÃ³n en MÃ©xico otros 50
 * habitantes, habrÃ¡ que actualizar la variable. */

habitantesMexico = habitantesMexico + 50

/* Pero aumentÃ³ otro mÃ¡s, aunque nos da un poco de flojera escribir todo de nuevo, asÃ­
 * que optamos por la siguiente operaciÃ³n: */

habitantesMexico += 1

/* Suponiendo que a alguien lo atropellÃ³ un perro, tendremos que disminuir la poblaciÃ³n
 * un habitante */

habitantesMexico -= 1

/* Si quisieramos saber cuÃ¡ntos habitantes habrÃ­a en caso de duplicarse la poblaciÃ³n,
 * harÃ­amos lo siguiente: */

habitantesMexico *= 2

/* Pero como no es el caso, hay que regresar a la normalidad: */

habitantesMexico /= 2

/* Supongamos que vamos a una reuniÃ³n, donde tenemos que repartir bitÃ¡coras para reporte.
 * Hay 6 asistentes, tenemos que saber cuÃ¡ntas bitÃ¡coras restan despuÃ©s de repartir entre
 * todos de manera equitativa*/

let numeroAgendas: Int = 50
let numeroAsistentes: Int = 6
sobrante = numeroAgendas % numeroAsistentes
print ("Nos sobran \(numeroAgendas) agendas y las guardaremos en la bodega.")



/* Operadores relacionales: SÃ­mbolos ocupados para comparar dos valores
 
 * Operador         Significado
 * ==               Igual que
 * >                Mayor que
 * >=               Mayor o igual que
 * <                Menor que
 * <=               Menor o igual que
 * !=               Diferente de	*/

/* Estructuras selectivas.
 
 * En estas estructuras nosotros podemos tomar decisiones evaluando una expresiÃ³n lÃ³gica,
 * que en pocas palabras es una combinaciÃ³n de constantes, variables o funciones, y segÃºn
 * el resultado se realizarÃ¡ una acciÃ³n u otra.
 
 * Ese resultado es un valor booleano.
 
 * Estas estructuras selectivas pueden ser:
 * Â· Simples
 * Â· Dobles
 * Â· MÃºltiples
 
 * Alternativa Simple
 
 * TambiÃ©n se le conoce como si - entonces y ejecuta una acciÃ³n al cumplir una condiciÃ³n.
 * Un ejemplo sencillo: "SI esta nublado, ENTONCES lloverÃ¡"
 
 * Si la condiciÃ³n es verdadera, entonces se ejecuta la acciÃ³n.
 * En caso contrario, no harÃ¡ nada.
 
 * Veamos el siguiente ejemplo: */

var minutosTranscurridos = 15

if minutosTranscurridos <= 20 {
    print("OK, tienes tu asistencia.")
}

/* Alternativa Doble
 
 * A diferencia del ejemplo anterior, este no estÃ¡ tan limitado y permite elegir entre
 * dos opciones o alternativas posibles, segÃºn se cumpla o no la condicion.
 
 * Si la condiciÃ³n es verdadera, entonces se ejecutarÃ¡ una acciÃ³n.
 * De lo contrario, se ejecutarÃ¡ otra.
 
 * Veamos el siguiente ejemplo: */

if minutosTranscurridos <= 20 {
    print("OK, tienes tu asistencia.")
} else {
    print("Tienes retardo.")
}

/* TambiÃ©n podemos declarar mÃ¡s bloques de cÃ³digo para evaluar cierto nÃºmero de
 * condiciones, tal como se puede ver en el siguiente ejemplo: */

minutosTranscurridos = 62

if minutosTranscurridos <= 20 {
    print("OK, tienes tu asistencia.")
} else if minutosTranscurridos <= 60{
    print("Tienes retardo.")
} else {
    print("Rayos. Al menos viniste y tienes salud.")
}

/* Operadores lÃ³gicos
 * Modifican o combinan los valores lÃ³gicos "true" y "false".
 
 * Hay 3 operadores lÃ³gicos estÃ¡ndar que soporta Swift:
 
 * Operador         Nombre          PropÃ³sito
 * !                NOT             Invierte un valor booleano: true pasa a
 *                                  ser false, false pasa a ser true.
 * &&               AND             ExpresiÃ³n lÃ³gica donde ambos valores
 *                                  tienen que ser true para que toda la 
 *                                  expresiÃ³n llegue a ser verdadera.
 * ||               OR              ExpresiÃ³n lÃ³gica donde si uno de los
 *                                  valores comparados llega a ser verdadero
 *                                  la expresiÃ³n serÃ¡ verdadera. 
 * Ejemplos: */

/* Alternativa MÃºltiple
 
 * En ocasiones se necesita que existan mÃ¡s de dos opciones posibles. Claro que se
 * podrÃ­a solucionar como en el caso anterior, pero al ser muchas opciones puede ser
 * un problema de escritura y legibilidad.
 
 * La estructura de decisiÃ³n mÃºltiple, o caso de, permitirÃ¡ que evaluemos una expresiÃ³n que
 * podrÃ¡ tomar diversos valores distintos. SegÃºn sea el caso, se realizarÃ¡ alguna de las
 * acciones posibles.
 
 * VÃ©ase el siguiente ejemplo: */

let semestre = 5

switch semestre {
    case 1:
        print("Tus materias son: Algoritmos, Algebra Lineal, Info I")
    case 3:
        print("Tus materias son: Derecho, Estructura de datos, Info III")
    case 5:
        print("Tus materias son: Finanzas Coorporativas, Mates Discretas, Info V")
    default:
        print("Posiblemente debas alguna materia aÃºn")
}

/* TambiÃ©n podemos evaluar mÃºltiples condiciones a la vez: */

let letrita = "z"

switch letrita {
    case "a", "e", "i", "o", "u":
        print("Es una vocal")
    default:
        print("Es una consonante")
}

/* Operadores de rango o intervalo
 * Swift ofrece dos operadores de rango o intervalo diferentes, que son una forma mÃ¡s corta
 * de expresar una serie de nÃºmeros 

 * A) Operador de intervalo cerrado: Define un rango de valores desde un nÃºmero "a" hasta 
 * un nÃºmero "b", incluyendo los valores que se encuentren entre "a" y "b".

 * B) Operador de intervalo medianamente abierto: Define un rango de valores de un nÃºmero
 * "a" hasta "b", sin incluir el nÃºmero "b". Como en el caso anterior, en este conjunto de 
 * numeros se incluyen los valores entre "a" y "b"*/

let edad: Int = 18

switch edad {
    case 0...5:
        print("El paciente estÃ¡ en la primer infancia.")
    case 6...11:
        print("El paciente es un infante.")
    case 12...18:
        print("El paciente es un adolescente.")
    case 18..<59:
        print("El paciente es un adulto.")
    default:
        print("El paciente es una persona de la tercera edad.")
}

/* Operadores ternarios
 
 * Hay veces que requerimos utilizar una sentencia if para obtener una variable o regresar
 * un valor. Nosotros harÃ­amos algo asÃ­: */

var mayor: Int = 0

let primerNumero = 17
let segundoNumero = 3

if primerNumero > segundoNumero {
    mayor = primerNumero
} else {
    mayor = segundoNumero
}

/* Pero todo lo prodrÃ­amos resumir a una sola lÃ­nea de cÃ³digo: */

mayor = primerNumero > segundoNumero ? primerNumero : segundoNumero

/* En la secciÃ³n posterior al signo de interrogaciÃ³n, se indicarÃ¡ el valor al ser verdadera
 * la expresiÃ³n, despuÃ©s de los dos puntos se colocarÃ¡ el valor al ser falsa.*/
 
/* Otro ejemplo puede ser el siguiente: */

var edad = 23
let respuestaEdad = edad >= 18 ? "Eres mayor de edad" : "No tienes INE :v"
print(respuestaEdad)

/* Estructuras de repeticiÃ³n
 * Bucle For-In
 * Se utiliza para hacer iteraciones en una secuencia, como en elementos de un 
 * arreglo, rango de nÃºmero o caracteres en una cadena.
 
 * Ejemplo con rango: */
 
 for indice in 1...10 {
    print("Bienvenido terrÃ­cola nÃºmero \(indice)")
 }
 
 // Ejemplo con arreglo
 
let invitados = ["Hugo", "Paco", "Luis", "Tribilin", "Miguelito", "Paolino Paperino"]

for nombre

/* Estructura bÃ sica de las funciones
 func nombreDeLaFuncion (parametros) -> tipoRetorno {
    // cuerpo de una funciÃ³n
} */

func mostrarNombre(){
    print("Mi nombre es: Cristian")
}

// AquÃ­ peso y altura son parÃ¡metros
func calcularIMC(peso: Float, altura: Float){
    let resultado = peso / (altura * altura)
    print("Tu IMC es de: \(resultado)")
}

// AquÃ­ peso y altura son argumentos
calcularIMC(peso: 68.3, altura: 1.60)

func calcularIMC2(peso: Float, altura: Float){
    let resultado = peso / (altura * altura)
    print("Tu IMC es de: \(resultado)")
    switch resultado {
    case 0...16.00:
        print("Tienes delgadez severa")
    case 16.00...16.99:
        print("Tienes delgadez moderada")
    case 17.00...18.49:
        print("Tienes delgadez aceptable")
    case 18.50...24.99:
        print("Tienes peso normal. Sigue asÃ­ :3")
    case 25.00...29.99:
        print("Tienes sobrepeso")
    case 30.00...34.99:
        print("Tienes obesidad tipo 1")
    case 35.00...40.00:
        print("Tienes obesidad tipo 2")
    default:
        print("Tienes obesidad tipo 3")
    }
}

calcularIMC2(peso: 69.3, altura: 1.60)

func diHola(a primerPersona: String, tambienA segundaPersona: String){
    print("Hola a \(primerPersona) y a \(segundaPersona)")
}

diHola(a: "Phineas", tambienA: "Ferb")

func materiasReprobadas(como materiaObligatoria: String, yTambien materiaOptativa: String){
    print("Reprobe la materia \(materiaObligatoria) y tambien \(materiaOptativa)")
}

//materiasReprobadas(materiaObligatoria: "InformÃ¡tica", materiaOptativa: "Seguridad")

materiasReprobadas(como: "Contabilidad", yTambien: "Coaching")

func ubicacionCoordenadas(_ abcisa: Int, _ ordenada: Int){
    print("El punto A esta en la coordenada (\(abcisa), \(ordenada))")
}

ubicacionCoordenadas(0, 1)

func sumar(operandoUno: Int, operandoDos: Int) -> Int{
    return operandoUno + operandoDos
}

print ("La suma da por resultado: \(sumar(operandoUno: 1, operandoDos: 1))")

let ejemplo = sumar(operandoUno: 3, operandoDos: 4)
ejemplo

func organizandoEquipos(_ nombreEquipo: String, _ puntuacion: Int = 0){
    print("El equipo: \(nombreEquipo) tiene: \(puntuacion) puntos.")
}

organizandoEquipos("Griffindor")

organizandoEquipos("Slyt", 100)
