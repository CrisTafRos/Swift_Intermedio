/* Documento: sesionUno.playground
 * Autor: Cristian Tafolla Rosales
 * Asignatura: Desarrollo con Swift
 * Semestre: 2020 - 1 */

import UIKit

/* Antes que nada, es necesario decir que comentar√© este c√≥digo como muchos otros
 * utilizando algunas notaciones sencillas*/

// Este es un comentario de una l√≠nea

/* Constantes y variables
 
 * En ambos casos, son espacios reservados en la memoria principal del equipo.
 * Las constantes y las variables son utilizadas para asociar un nombre con un valor.

 * Constante: Tiene un valor ajustado que no requiere que sea cambiado durante el
 * "tiempo de vida" de un programa, siendo m√°s claros y seguros.
 * Podemos definir las constantes con la palabra reservada let, como en el siguiente
 * ejemplo: */

let curso = "Desarrollo con Swift"

/* La sentencia anterior nos indica que existir√° una nueva constante llamada curso
 * y se le asigno el valor Desarrollo con Swift a dicha constante.

 * En la siguiente l√≠nea imprimiremos el valor de dicha constante, la cu√°l aparecer√°
 * en la consola que se encuentra en la parte inferior de nuestra ventana activa.:*/

print (curso)

/* Variable: En caso de requerir un valor que cambie durante la ejecuci√≥n del programa,
 * utilizamos una variable.
 * Podemos declarar las variables con la palabra reservada var, como en el siguiente
 * ejemplo: */

var numeroAlumnos = 6

/* Adicionalmente, vemos que Swift usa inferencia de tipos para seguir
 * trabajando con el tipo adecuado, al declarar una constante o variable con
 * valor inicial.

 * Suponiendo que tenemos la siguiente instrucci√≥n: */

let pi = 3 + 0.14159

/* El valor literal 3 no tiene un tipo expl√≠cito, as√≠ que se tomar√° el tipo m√°s
 * apropiado para almacenar este valor, que en este caso es Double.*/

/* Al guardar los valores, vemos que tenemos que brindarle un nombre diferente a cada
 * uno, como por ejemplo: */

var saludo = "Hola"
var –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ = "–ø—Ä–∏–≤–µ—Ç"
var ÂÆ£Ë®Ä = "ÁßÅ„ÅØ„ÅÇ„Å™„Åü„ÇíÊÑõ„Åó„Å¶„ÅÑ„Çã"
var üòÑ = "Feliz"

/* Estos nombres pueden contener cualquier caracter, incluyendo los caracteres Unicode.

 * Pero lo ideal ser√≠a nombrar las variables con un lenguaje entendible por el grupo
 * de personas que pudisesen verlo, claro, que si queremos que sea algo universal
 * tendremos que utilizar el ingl√©s, y adicionalmente utilizaremos una notaci√≥n
 * denominada CamelCase.
 * La notaci√≥n CamelCase separa cada palabra con una may√∫scula, y no con espacios
 * entre las palabras. Hay dos formas de utilizarla: */

var numeroAlumnosAprobados = 20 // Utiliza lowerCamelCase

var NumeroAlumnosReprobados = 1 // Utiliza UpperCamelCase

// Lo mejor es utilizar lowerCamelCase.

/* Cabe recalcar que no necesariamente se tiene que imprimir el valor de una variable
 * o constante sola, sino que tambi√©n podemos agregar texto de manera contigua.
 * Hay dos formas de hacerlo:
 * 1. Concatenaci√≥n: Utilizaremos el s√≠mbolo "+" entre las cadenas de caracteres.
 * Ejemplo: */

print ("Hola a los " + numeroAlumnos + " del semestre actual")

/* 2. Interpolaci√≥n: Utilizaremos los s√≠mbolos \() , y en medio de los par√©ntesis 
 * podremos el nombre del espacio de memoria reservado. Ejemplo: */

print ("Actualmente hay \(numeroAlumnos) alumnos inscritos")

/* Suponiendo que esta variable corresponda al n√∫mero de alumnos que el curso tiene y
 * en caso de que lleguen m√°s, entonces podr√≠amos cambiar el valor almacenado en dicha 
 * variable de la siguiente forma: */

numeroAlumnos = 22
print ("Actualmente hay \(numeroAlumnos) alumnos inscritos")

/* Tambi√©n podemos declarar multiples constantes o variables en la misma l√≠nea.*/

let alumnoUno = "Alejandro", alumnoDos = "Julieta", alumnoTres = "Ariel"
var equipoUno = "Ocupado", equipoDos = "Desocupado", equipoTres = "En mantenimiento"

/* Si quisieramos cambiar el valor de una constante, veremos que saldr√° un error.
 * Descomenta la l√≠nea de abajo y observa todo lo que aparece. */

//curso = "Teor√≠a del meme"

/* Como vimos, no es posible cambiar el valor de alguno de las constantes.*/

/* Tipos de datos
 * Los tipos de datos m√°s comunes en Swift son los siguientes:
 
 * Tipo de dato         Palabra reservada           Prop√≥sito
 
 * Entero               Int                         Representa n√∫meros enteros
 * Flotantes            Float                       Representa n√∫meros con punto
 *                                                  decimal (6 decimales).
 * Double               Double                      Representa n√∫meros con punto
 *                                                  decimal, con el doble de
 *                                                  precisi√≥n que los flotantes
 *						                                            (15 decimales)
 * Booleano             Bool                        Representa dos valores:
 *                                                  verdadero y falso (true / 
 *						                                            false)
 * Cadena               String                      Representa texto
 
 * Nosotros podemos ver ejemplos en la parte de abajo: */

var entero: Int = 4
var flotante: Float = 4.66666666666
var double: Double = 4.666666666666
var booleano: Bool = true
var cadena: String = "iOS Dev Lab"

/* Al agregar nosotros el tipo de la variable que estamos definiendo, hacemos que
 * nuestra variable tenga tipado fuerte. Aprovechando esta cualidad del lenguaje,
 * podemos ser m√°s claros con los tipos de valor para trabajar y evitar errores.
 
 * Pero, ¬øqu√© tal si nosotros no definimos ese tipo? */

var materiaReprobada = "Matem√°ticas financieras"

/* Aqu√≠ utilizamos la inferencia de tipo, donde vemos que no es necesario que
 * agreguemos el tipo, aunque lo mejor ser√≠a que lo hicieramos üôÉ*/

/* Anotaciones de tipo
 * Podemos declarar claramente el tipo de valor que almacenar√° una constante o 
 * una variable antes de incluir un valor.
 * Por ejemplo: */

var mensajeBienvenido: String

// para despues continuar asignando valores:

mensajeBienvenido = "¬°Qu√© tal todos!"

/* De igual forma podemos definir m√∫ltiples variables con el mismo tipo sobre
 * la misma l√≠nea de c√≥digo, de manera contigua al nombre de la variable final*/

// Algunos ejemplos simples:

/* Se nos presenta el siguiente problema:
 
 * "La poblaci√≥n en M√©xico ascend√≠a a los 119,938,473 habitantes." (INEGI, 2015)
 
 * Si requiero guardar esa informaci√≥n en una variable, lo hago de esta manera: */

var habitantesMexico: Int = 119938473

/* Lo anterior no me permite leer f√°cilmente el n√∫mero de habitantes, pues estamos
 * acostumbrados a leer las cantidades con comas que separan por miles. Bien,
 * Swift puede permitirnos hacer lo siguiente:
 
 * "Para 2019, la poblaci√≥n en M√©xico aument√≥ a 133,337,506 habitantes." (CountryMeters, 2019)
 
 * Ahora hay que guardar dicha informaci√≥n en la variable: */

habitantesMexico = 133_337_526

/* Dicha notaci√≥n no cambiar√° el tipo de la variable que ocup√°bamos con  
 * anterioridad y, como vemos, es m√°s f√°cil leerla ahora.*/

/* Operadores: S√≠mbolos especiales utilizados para cambiar o combinar valores
 
 * Operadores aritm√©ticos:
 
 * Ahora hagamos algo diferente. Tenemos la siguiente informaci√≥n:
 
 * "La poblaci√≥n masculina actual del pa√≠s es de 65,757,788 habitantes, correspondiente
 * al 49.3%." (CountryMeters, 2019)
 
 * Necesitamos saber ahora cu√°ntas mujeres hay actualmente en M√©xico. */

var habitantesMujeres: Int = habitantesMexico - 65_757_788

/* Veremos en la barra lateral de resultados que actualmente hay en M√©xico 67,579,738
 * mujeres. Despu√©s nos dan m√°s informaci√≥n:
 
 * "La poblaci√≥n femenina en M√©xico corresponde al 50.7% del total." (CountryMeters, 2019)
 
 * Necesitamos hacer el c√°lculo para saber si es cierta esta afimaci√≥n. */

50.7 + 49.3

/* Tambi√©n nos solicitan cu√°ntos habitantes hay por kil√≥metro cuadrado en el pa√≠s,
 * teniendo el siguiente dato:
 
 * "La extensi√≥n de la superficie continental de M√©xico es de 1,960,189 kil√≥metros
 * cuadrados" (INEGI, 2010) */

var superficieMexico: Int = 1_960_189

var densidadPoblacionMexico: Float

// Descomenta la l√≠nea de abajo, y ver√°s que hay un error, aunque l√≥gicamente est√° bien

// densidadPoblacionMexico = habitantesMexico / superficieMexico

/* Es importante recalcar que obtendr√°s un valor con punto decimal, as√≠ que se usa un
 * casteo, que es una forma de que le indiquemos al compilador que haremos una conversi√≥n
 * para no perder informaci√≥n que nos pueda ser √∫til o que hayan problemas en nuestro
 * programa. Lo utilizamos de la siguiente forma: */

densidadPoblacionMexico = Float (habitantesMexico / superficieMexico)

// Vemos que hay 68 personas por kil√≥metro cuadrado, aproximadamente.

/* Nos brindan m√°s informaci√≥n:
 
 * "La densidad de carreteras en el pa√≠s corresponde a los 19 kil√≥metros por kil√≥metro
 * cuadrado" (SEMARNAT, 2015).

 * Hagamos otra operaci√≥n. */

var densidadCarreterasMexico: Int = 19

var carreterasMexico: Int = densidadCarreterasMexico * superficieMexico

/* Asignaci√≥n compuesta
 
 * Suponiendo que en lo que llevamos hablando aument√≥ la poblaci√≥n en M√©xico otros 50
 * habitantes, habr√° que actualizar la variable. */

habitantesMexico = habitantesMexico + 50

/* Pero aument√≥ otro m√°s, aunque nos da un poco de flojera escribir todo de nuevo, as√≠
 * que optamos por la siguiente operaci√≥n: */

habitantesMexico += 1

/* Suponiendo que a alguien lo atropell√≥ un perro, tendremos que disminuir la poblaci√≥n
 * un habitante */

habitantesMexico -= 1

/* Si quisieramos saber cu√°ntos habitantes habr√≠a en caso de duplicarse la poblaci√≥n,
 * har√≠amos lo siguiente: */

habitantesMexico *= 2

/* Pero como no es el caso, hay que regresar a la normalidad: */

habitantesMexico /= 2

/* Supongamos que vamos a una reuni√≥n, donde tenemos que repartir bit√°coras para reporte.
 * Hay 6 asistentes, tenemos que saber cu√°ntas bit√°coras restan despu√©s de repartir entre
 * todos de manera equitativa*/

let numeroAgendas: Int = 50
let numeroAsistentes: Int = 6
sobrante = numeroAgendas % numeroAsistentes
print ("Nos sobran \(numeroAgendas) agendas y las guardaremos en la bodega.")



/* Operadores relacionales: S√≠mbolos ocupados para comparar dos valores
 
 * Operador         Significado
 * ==               Igual que
 * >                Mayor que
 * >=               Mayor o igual que
 * <                Menor que
 * <=               Menor o igual que
 * !=               Diferente de	*/

/* Estructuras selectivas.
 
 * En estas estructuras nosotros podemos tomar decisiones evaluando una expresi√≥n l√≥gica,
 * que en pocas palabras es una combinaci√≥n de constantes, variables o funciones, y seg√∫n
 * el resultado se realizar√° una acci√≥n u otra.
 
 * Ese resultado es un valor booleano.
 
 * Estas estructuras selectivas pueden ser:
 * ¬∑ Simples
 * ¬∑ Dobles
 * ¬∑ M√∫ltiples
 
 * Alternativa Simple
 
 * Tambi√©n se le conoce como si - entonces y ejecuta una acci√≥n al cumplir una condici√≥n.
 * Un ejemplo sencillo: "SI esta nublado, ENTONCES llover√°"
 
 * Si la condici√≥n es verdadera, entonces se ejecuta la acci√≥n.
 * En caso contrario, no har√° nada.
 
 * Veamos el siguiente ejemplo: */

var minutosTranscurridos = 15

if minutosTranscurridos <= 20 {
    print("OK, tienes tu asistencia.")
}

/* Alternativa Doble
 
 * A diferencia del ejemplo anterior, este no est√° tan limitado y permite elegir entre
 * dos opciones o alternativas posibles, seg√∫n se cumpla o no la condicion.
 
 * Si la condici√≥n es verdadera, entonces se ejecutar√° una acci√≥n.
 * De lo contrario, se ejecutar√° otra.
 
 * Veamos el siguiente ejemplo: */

if minutosTranscurridos <= 20 {
    print("OK, tienes tu asistencia.")
} else {
    print("Tienes retardo.")
}

/* Tambi√©n podemos declarar m√°s bloques de c√≥digo para evaluar cierto n√∫mero de
 * condiciones, tal como se puede ver en el siguiente ejemplo: */

minutosTranscurridos = 62

if minutosTranscurridos <= 20 {
    print("OK, tienes tu asistencia.")
} else if minutosTranscurridos <= 60{
    print("Tienes retardo.")
} else {
    print("Rayos. Al menos viniste y tienes salud.")
}

/* Operadores l√≥gicos
 * Modifican o combinan los valores l√≥gicos "true" y "false".
 
 * Hay 3 operadores l√≥gicos est√°ndar que soporta Swift:
 
 * Operador         Nombre          Prop√≥sito
 * !                NOT             Invierte un valor booleano: true pasa a
 *                                  ser false, false pasa a ser true.
 * &&               AND             Expresi√≥n l√≥gica donde ambos valores
 *                                  tienen que ser true para que toda la 
 *                                  expresi√≥n llegue a ser verdadera.
 * ||               OR              Expresi√≥n l√≥gica donde si uno de los
 *                                  valores comparados llega a ser verdadero
 *                                  la expresi√≥n ser√° verdadera. 
 * Ejemplos: */

/* Alternativa M√∫ltiple
 
 * En ocasiones se necesita que existan m√°s de dos opciones posibles. Claro que se
 * podr√≠a solucionar como en el caso anterior, pero al ser muchas opciones puede ser
 * un problema de escritura y legibilidad.
 
 * La estructura de decisi√≥n m√∫ltiple, o caso de, permitir√° que evaluemos una expresi√≥n que
 * podr√° tomar diversos valores distintos. Seg√∫n sea el caso, se realizar√° alguna de las
 * acciones posibles.
 
 * V√©ase el siguiente ejemplo: */

let semestre = 5

switch semestre {
    case 1:
        print("Tus materias son: Algoritmos, Algebra Lineal, Info I")
    case 3:
        print("Tus materias son: Derecho, Estructura de datos, Info III")
    case 5:
        print("Tus materias son: Finanzas Coorporativas, Mates Discretas, Info V")
    default:
        print("Posiblemente debas alguna materia a√∫n")
}

/* Tambi√©n podemos evaluar m√∫ltiples condiciones a la vez: */

let letrita = "z"

switch letrita {
    case "a", "e", "i", "o", "u":
        print("Es una vocal")
    default:
        print("Es una consonante")
}

/* Operadores de rango o intervalo
 * Swift ofrece dos operadores de rango o intervalo diferentes, que son una forma m√°s corta
 * de expresar una serie de n√∫meros 

 * A) Operador de intervalo cerrado: Define un rango de valores desde un n√∫mero "a" hasta 
 * un n√∫mero "b", incluyendo los valores que se encuentren entre "a" y "b".

 * B) Operador de intervalo medianamente abierto: Define un rango de valores de un n√∫mero
 * "a" hasta "b", sin incluir el n√∫mero "b". Como en el caso anterior, en este conjunto de 
 * numeros se incluyen los valores entre "a" y "b"*/

let edad: Int = 18

switch edad {
    case 0...5:
        print("El paciente est√° en la primer infancia.")
    case 6...11:
        print("El paciente es un infante.")
    case 12...18:
        print("El paciente es un adolescente.")
    case 18..<59:
        print("El paciente es un adulto.")
    default:
        print("El paciente es una persona de la tercera edad.")
}

/* Operadores ternarios
 
 * Hay veces que requerimos utilizar una sentencia if para obtener una variable o regresar
 * un valor. Nosotros har√≠amos algo as√≠: */

var mayor: Int = 0

let primerNumero = 17
let segundoNumero = 3

if primerNumero > segundoNumero {
    mayor = primerNumero
} else {
    mayor = segundoNumero
}

/* Pero todo lo prodr√≠amos resumir a una sola l√≠nea de c√≥digo: */

mayor = primerNumero > segundoNumero ? primerNumero : segundoNumero

/* En la secci√≥n posterior al signo de interrogaci√≥n, se indicar√° el valor al ser verdadera
 * la expresi√≥n, despu√©s de los dos puntos se colocar√° el valor al ser falsa.*/
 
/* Otro ejemplo puede ser el siguiente: */

var edad = 23
let respuestaEdad = edad >= 18 ? "Eres mayor de edad" : "No tienes INE :v"
print(respuestaEdad)

/* Estructuras de repetici√≥n
 * Bucle For-In
 * Se utiliza para hacer iteraciones en una secuencia, como en elementos de un 
 * arreglo, rango de n√∫mero o caracteres en una cadena.
 
 * Ejemplo con rango: */
 
 for indice in 1...10 {
    print("Bienvenido terr√≠cola n√∫mero \(indice)")
 }
 
 // Ejemplo con arreglo
 
let invitados = ["Hugo", "Paco", "Luis", "Tribilin", "Miguelito", "Paolino Paperino"]

for gorron in invitados {
    print("Te invito a mi fiesta. \(gorron)")
}

/* Si no necesitamos un valor en cada secuencia, podemos ignorarlos y poner un gui√≥n
 * bajo en vez del nombre de la variable.*/
 
let base = 2
let potencia = 8
var acumulador = 1

for _ in 1...potencia {
    acumulador *= base
}

/* Arreglo: Grupo o colecci√≥n finita, homog√©nea y ordenada de
 * elementos.
 * Es un conjunto de datos homog√©neos que se encuentran ubicados
 * de forma consecutiva en la memoria primaria (RAM). */
    
let alfabetoGriego = ["Alfa", "Beta", "Gama", "Delta", "Epsilon", "Dseta", "Eta", "Theta"]

/* ¬øQu√© tal si necesitamos saber en qu√© √≠ndice se encuentra almacenado un valor? */

let potencias : [Int] = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049]

/* enumerated()
*  Regresa una secuencia de pares (n, x), donde n representa un entero consecutivo iniciando
*  en cero y x representa un elemento de dicha secuencia. */

for (n, potencia) in potencias.enumerated(){
    print("3^\(n) = \(potencia)")
}

/* ¬øQu√© tal si necesitamos cada letra de una cadena? */

for caracter in "Compumundohipermegared"{
   print(caracter)
}

/* Estructura repetitiva while
 * Este bucle se repite hasta que una condici√≥n sea falsa. Es principalmente usada cuando
 * se necesita repetir algo, pero no se tiene un n√∫mero espec√≠fico de veces. Esta
 * condici√≥n se evalua al INICIO del bucle. */

var tope : Int = 0
while (tope < 4) {
   print (tope)
   tope += 1
}

/* Estructura repetitiva repeat-while
 * Este bucle se ve casi igual que el anterior, pero la condici√≥n se evalua al FINAL del
 * dicho ciclo. Recuerda que se ejecuta al menos una vez. */

var acumulado : Int = 0

repeat {
   print (acumulado)
} while (acumulado < 2)

/* Estructura b√†sica de las funciones
 func nombreDeLaFuncion (parametros) -> tipoRetorno {
    // cuerpo de una funci√≥n
} */

func mostrarNombre(){
    print("Mi nombre es: Cristian")
}

// Aqu√≠ peso y altura son par√°metros
func calcularIMC(peso: Float, altura: Float){
    let resultado = peso / (altura * altura)
    print("Tu IMC es de: \(resultado)")
}

// Aqu√≠ peso y altura son argumentos
calcularIMC(peso: 68.3, altura: 1.60)

func calcularIMC2(peso: Float, altura: Float){
    let resultado = peso / (altura * altura)
    print("Tu IMC es de: \(resultado)")
    switch resultado {
    case 0...16.00:
        print("Tienes delgadez severa")
    case 16.00...16.99:
        print("Tienes delgadez moderada")
    case 17.00...18.49:
        print("Tienes delgadez aceptable")
    case 18.50...24.99:
        print("Tienes peso normal. Sigue as√≠ :3")
    case 25.00...29.99:
        print("Tienes sobrepeso")
    case 30.00...34.99:
        print("Tienes obesidad tipo 1")
    case 35.00...40.00:
        print("Tienes obesidad tipo 2")
    default:
        print("Tienes obesidad tipo 3")
    }
}

calcularIMC2(peso: 69.3, altura: 1.60)

func diHola(a primerPersona: String, tambienA segundaPersona: String){
    print("Hola a \(primerPersona) y a \(segundaPersona)")
}

diHola(a: "Phineas", tambienA: "Ferb")

func materiasReprobadas(como materiaObligatoria: String, yTambien materiaOptativa: String){
    print("Reprobe la materia \(materiaObligatoria) y tambien \(materiaOptativa)")
}

//materiasReprobadas(materiaObligatoria: "Inform√°tica", materiaOptativa: "Seguridad")

materiasReprobadas(como: "Contabilidad", yTambien: "Coaching")

func ubicacionCoordenadas(_ abcisa: Int, _ ordenada: Int){
    print("El punto A esta en la coordenada (\(abcisa), \(ordenada))")
}

ubicacionCoordenadas(0, 1)

func sumar(operandoUno: Int, operandoDos: Int) -> Int{
    return operandoUno + operandoDos
}

print ("La suma da por resultado: \(sumar(operandoUno: 1, operandoDos: 1))")

let ejemplo = sumar(operandoUno: 3, operandoDos: 4)
ejemplo

func organizandoEquipos(_ nombreEquipo: String, _ puntuacion: Int = 0){
    print("El equipo: \(nombreEquipo) tiene: \(puntuacion) puntos.")
}

organizandoEquipos("Griffindor")

organizandoEquipos("Slyt", 100)
